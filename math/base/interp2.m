function vq = interp2(x,y,v,xq,yq,method,extrapval)

	% default method
	if isempty(method); method = 'linear'; end
	
	% default extrapval
	extrapvalspline = false;	% in spline, extrapolated queries are not set to extrapval unless specified
	if isempty(extrapval)
		extrapval = NaN
	else
		extrapvalspline = true	% the user has specified a value for extrapolated queries, then spline set these queries to extrapval
	end
	
	% check for errors entering the method 
	if ~strcmp(method,'linear') & ~strcmp(method,'cubic') & ~strcmp(method,'nearest') & ~strcmp(method,'spline')
		error('invalid interpolation type specified.')	
	end	

	% check x and y are strictly increasing monotonic
	% also check minimum sizes for x and y and
	% changes cubic method to linear or spline if required
	method = chckmonotsize(x,y,method)
	
	% check direction of vectors and size 
	% of vectors and matrix v
	[x,y,xq,yq,diagsol,outcol] = chckxyv(x,y,v,xq,yq)
		
	% find the indices and relative positions of the elements of xq and yq
	% within the meshgrid generated by the elements of x and y

	if ~strcmp(method,'spline')
	
		% find the lower indices
		idxl = indices(x(1,:),xq(1,:))	
		idyl = indices(y(:,1),yq(:,1))		
		
		if ~strcmp(method,'cubic')
		
			% determine the upper indices
			idxu = idxl+1
			idyu = idyl+1
		
		end
		
	end		
	
	if strcmp(method,'cubic') | strcmp(method,'nearest')
	
		% distance between two consecutive elements in x
		[~,lengthx]=size(x)
		dx = (x(1,end)-x(1,1))/(lengthx-1)
	
		% distance between two consecutive elements in y
		[lengthy,~]=size(y)
		dy = (y(end,1)-y(1,1))/(lengthy-1)		
	
	end	

	% find the indices of the out of domain points 
	oodx = xq > max(x(1,:)) | xq < min(x(1,:)) 
	oody = yq > max(y(:,1)) | yq < min(y(:,1)) 

	% perform the interpolation	
	if strcmp(method,'linear')	
		
		xu = x(idyu,idxu)
		xl = x(idyl,idxl)
		yu = y(idyu,idxu)
		yl = y(idyl,idxl)	
				
		vq = 	v(idyl,idxl).*(xu-xq).*(yu-yq) + ...
				v(idyl,idxu).*(xq-xl).*(yu-yq) + ...
				v(idyu,idxl).*(xu-xq).*(yq-yl) + ...
				v(idyu,idxu).*(xq-xl).*(yq-yl)

		factor = 1./((xu-xl).*(yu-yl))	

		vq = factor .* vq
		
	elseif strcmp(method,'cubic')
	
		% expand v at the edges adding zeros around
		[nr,nc] = size(v)
		v = [zeros(1,nc);v;zeros(1,nc)]
		v = [zeros(nr+2,1) v zeros(nr+2,1)]
	
		% substitute the new zeros with new extrapolated data
		% this makes the interpolated values to be an O(h3) approximation
		v(1,2:nc+1) = 3*v(2,2:nc+1)-3*v(3,2:nc+1)+v(4,2:nc+1)				% top new row
		v(nr+2,2:nc+1) = 3*v(nr+1,2:nc+1)-3*v(nr,2:nc+1)+v(nr-1,2:nc+1)		% bottom new row
		v(:,1) = 3*v(:,2)-3*v(:,3)+v(:,4)									% left new column
		v(:,nc+2) = 3*v(:,nc+1)-3*v(:,nc)+v(:,nc-1)							% right new column

		% coefficients for the interpolation in the x-direction
		i = (xq(1,:)-x(1,idxl))/dx
		I0 = (-i.^3+2*i.^2-i)
		I1 = (3*i.^3-5*i.^2+2)
		I2 = (-3*i.^3+4*i.^2+i)
		I3 = (i.^3-i.^2)
	
		% coefficients for the interpolation in the y-direction
		j = (yq(:,1)-y(idyl,1))/dy
		J0 = (-j.^3+2*j.^2-j)
		J1 = (3*j.^3-5*j.^2+2)
		J2 = (-3*j.^3+4*j.^2+j)
		J3 = (j.^3-j.^2)
	
		% update the indices to the new size of v
		idxl = idxl+1
		idxu = idxl+1	
		idyl = idyl+1
		idyu = idyl+1
	
		% interpolate in the x-direction
		vqx0 = v(idyl-1,idxl-1).*I0+ v(idyl-1,idxl).*I1 + v(idyl-1,idxu).*I2 + v(idyl-1,idxu+1).*I3
		vqx1 = v(idyl,idxl-1).*I0+ v(idyl,idxl).*I1 + v(idyl,idxu).*I2 + v(idyl,idxu+1).*I3
		vqx2 = v(idyu,idxl-1).*I0+ v(idyu,idxl).*I1 + v(idyu,idxu).*I2 + v(idyu,idxu+1).*I3
		vqx3 = v(idyu+1,idxl-1).*I0+ v(idyu+1,idxl).*I1 + v(idyu+1,idxu).*I2 + v(idyu+1,idxu+1).*I3	
	
		% interpolate in the y-direction
		vq = vqx0.*J0 + vqx1.*J1 + vqx2.*J2 + vqx3.*J3
		
		% devide by 4 as division by 2 was not previously included 
		% in coefficients I's and J's
		vq = vq/4
		
	elseif strcmp(method,'nearest')
	
		% update distances to half of the actual gap
		dx = dx/2
		dy = dy/2
	
		% initialize solution setting vq to be equal to the 
		% top-right corner's values
		vq = v(idyu,idxu)
	
		% substitute solution when the nearest value is at the
		% bottom-left corner
		[yc,xc] = find(xq-dx <  x(idyl,idxl) & yq-dy < y(idyl,idxl))	% indices of positions at which bottom-left corner is the nearest
		yc = unique(yc)													% ensure these indices are not repeated 
		xc = unique(xc)
		vtoc = v(idyl,idxl)												% bottom-left values
		vq(yc,xc) = vtoc(yc,xc)											% substitute  these values only at the correct positions
	
		% substitute solution when the nearest value is at the
		% top-left corner
		[yc,xc] = find(xq-dx <  x(idyl,idxl) & yq+dy >= y(idyu,idxl))
		yc = unique(yc)
		xc = unique(xc)
		vtoc = v(idyu,idxl)
		vq(yc,xc) = vtoc(yc,xc)
	
		% substitute solution when the nearest value is at the
		% bottom-right corner
		[yc,xc] = find(xq+dx >=  x(idyl,idxu) & yq-dy < y(idyl,idxu))
		yc = unique(yc)
		xc = unique(xc)
		vtoc = v(idyl,idxu)
		vq(yc,xc) = vtoc(yc,xc)
		
	elseif strcmp(method,'spline')
		
		% interpolate in the x-direction
		v = spline(x(1,:),v,xq(1,:))
		
		% interpolate in the y-direction
		vq = spline(y(:,1),v',yq(:,1))'
		
	end

	% update the extrapval values
	if ~strcmp(method,'spline') 	% in spline, extrapolated queries are not set to extrapval unless specified
		vq(oodx|oody) = extrapval
	else
		if extrapvalspline 
			vq(oodx|oody) = extrapval	% if the user has specified a value for extrapolated queries, then spline set these queries to extrapval
		end
	end
	
	% Final solution is only the main diagonal of vq
	% when xq and xq are scattered points
	if diagsol; vq = diag(vq)';	end
	
	if outcol; vq = vq'; end

end


function idl = indices(x,xq)

	idl = ones(size(xq))
	n = length(x)
	
	for j = 2:n-1
		idl(x(j) <= xq) = j
	end

end

function method = chckmonotsize(x,y,method)

	% checks minimum x, y sizes for interp2 to work
	if isscalar(x) | isscalar(y)
		error('interpolation requires at least two sample points in each dimension')
	end 

	% selects data to check for monotonic when x and y are vectors
	% makes sure x and y have the correct direction to be considered
	% grid vectors
	if isvector(x); x=x(:)'; end
	if isvector(y); y=y(:); end	

	% checks x and y are valid meshgrid matrices and 
	% selects data to check for monotonic in this case
	[nrx,~] = size(x); 
	if nrx > 1 								% x is a matrix
	
		% checks all rows are the same 
		if ~all(ismember(x,x(1,:),'rows'))
			error('input grid is not a valid meshgrid')
		end
		
		% selects data
		x = x(1,:)
		
	end
	[nry,~] = size(y)
	if nry > 1								% y is a matrix
	
		% checks all columns are the same 
		if ~all(all(ismember(y,y(:,1))))
			error('input grid is not a valid meshgrid')
		end
	
		% selects data
		y = y(:,1)

	end
	
	% stores data to be utilised in monotonic checks
	diffx = diff(x)
	diffy = diff(y)
	
	% checks whether there are repeated coordinates 
	if any(diffx == 0) | any(diffy == 0)
		error('the grid vectors must contain unique points')
	end
	
	% checks x and y are sorted in increasing order
	if ~all(diffx > 0) | ~all(diffy > 0)
		error('the grid vectors must be strictly monotonically increasing')
	end
		
	% checks minimum size for cubic method
	% makes sure there is at least 3 points in each direction
	% if not, the cubic method is changed to linear 
	[~,noptx] = size(x)
	[nopty,~] = size(y)
	if (noptx < 3 | nopty < 3) & strcmp(method,'cubic')
	
		% sets to linear method & show warning	
		method = 'linear'
		fprintf('warning: the ''cubic'' method requires at least 3 points in each dimension\n')
		fprintf('reverting to the default ''linear'' method because this condition is not met\n')		
		
	end	

	% checks whether elements in the grids are uniformily distributed
	% if not, the cubic method is changed to spline 
	if (any(abs(diff(diffx)-0) > eps) | any(abs(diff(diffy)-0) > eps)) & strcmp(method,'cubic')
	
		% sets to spline method & show warning	
		method = 'spline'
		fprintf('warning: the ''cubic'' method requires the grid to have a uniform spacing\n')	
		fprintf('switching the method from ''cubic'' to ''spline'' because this condition is not met\n')		
		
	end

end

function [x,y,xq,yq,diagsol,outcol] = chckxyv(x,y,v,xq,yq)

	diagsol = false
	outcol = false
	
	if isvector(x) & isvector(y)	
	
		[nrv,ncv] = size(v)		
		if nrv ~= length(y) | ncv ~= length(x)
			error('the grid vectors do not define a grid of points that match the given values')
		else
			[x,y] = meshgrid(x,y)
		end
	
	end
	
	if isvector(xq) & isvector(yq)		
		
		% when both vectors have the same orientation they are not treated
		% as grid vectors but xq and yq are treated as scattered points.
		% Then the final solution is only the main diagonal of vq
		if (iscolumn(xq) & iscolumn(yq)) | (~iscolumn(xq) & ~iscolumn(yq)) 	
		
			diagsol = true 				
			if (iscolumn(xq) & iscolumn(yq)); outcol = true; end
			
		end
		
		[xq,yq] = meshgrid(xq,yq)
		
	end	

end



